<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>False - TraceContract documentation - tracecontract.Formulas.False</title>
          <meta name="description" content="False - TraceContract documentation - tracecontract.Formulas.False" />
          <meta name="keywords" content="False TraceContract documentation tracecontract.Formulas.False" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript">
         if(top === self) {
            var url = '../index.html';
            var hash = 'tracecontract.Formulas$False$';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="value">
      <div id="definition">
        <img src="../lib/object_big.png" />
        <p id="owner"><a href="package.html" class="extype" name="tracecontract">tracecontract</a>.<a href="Formulas.html" class="extype" name="tracecontract.Formulas">Formulas</a></p>
        <h1>False</h1>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <span class="name">False</span><span class="result"> extends <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>The value <i>false</i>.
</p></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><span class="extype" name="scala.Serializable">Serializable</span>, <span class="extype" name="java.io.Serializable">Serializable</span>, <span class="extype" name="scala.Product">Product</span>, <span class="extype" name="scala.Equals">Equals</span>, <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a>, <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="tracecontract.Formulas.False"><span>False</span></li><li class="in" name="scala.Serializable"><span>Serializable</span></li><li class="in" name="java.io.Serializable"><span>Serializable</span></li><li class="in" name="scala.Product"><span>Product</span></li><li class="in" name="scala.Equals"><span>Equals</span></li><li class="in" name="tracecontract.Formulas.Formula"><span>Formula</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
            <a href="http://docs.scala-lang.org/overviews/scaladoc/usage.html#members" target="_blank">Learn more about member selection</a>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:AnyRef):Boolean"></a>
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a>
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:AnyRef):Boolean"></a>
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a>
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="tracecontract.Formulas.Formula#and" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="and(that:Formulas.this.Formula):Formulas.this.Formula"></a>
      <a id="and(Formula):Formula"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">and</span><span class="params">(<span name="that">that: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>)</span><span class="result">: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Logical <i>and</i> (conjunction) of two formulas.</p><div class="fullcomment"><div class="comment cmt"><p>Logical <i>and</i> (conjunction) of two formulas.
The formula evaluates to True if and only if both formulas evaluate to True.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>the right hand argument of the conjunction.</p></dd><dt>returns</dt><dd class="cmt"><p>the <i>and</i>-formula.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></dd></dl></div>
    </li><li name="tracecontract.Formulas.False#apply" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="apply(event:Event):Formulas.this.Formula"></a>
      <a id="apply(Event):Formula"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">apply</span><span class="params">(<span name="event">event: <span class="extype" name="tracecontract.Formulas.Event">Event</span></span>)</span><span class="result">: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="tracecontract.Formulas.False">False</a> → <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="tracecontract.Formulas.Formula#causes" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="causes(that:Formulas.this.Formula):Formulas.this.Formula"></a>
      <a id="causes(Formula):Formula"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">causes</span><span class="params">(<span name="that">that: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>)</span><span class="result">: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Causal composition of formulas.</p><div class="fullcomment"><div class="comment cmt"><p>Causal composition of formulas.
The formula <i>f<sub>1</sub> causes f<sub>2</sub></i> has the following interpretation:
<i>f<sub>1</sub></i> is first evaluated. If it evaluates to False, the whole formula evaluates to True.
If it evaluates to True, evaluation <b>at that point</b> (and not before) continues with <i>f<sub>2</sub></i>.</p><p>Take for example the following formula (compare to the semantics of <i>f<sub>1</sub> implies f<sub>2</sub></i>):</p><p><br></p><p><pre>
eventually(REPORT("REBOOT")) causes eventually(REPORT("CALL_HOME"))
</pre></p><p><br></p><p>This formula states that (from now on) if there is eventually
a report of a reboot, then <b>there after</b> there should eventually be a report
on call to home. Consider the two traces:</p><p><br></p><p><pre>
trace1 = List(...,REPORT("REBOOT"),...,REPORT("CALL_HOME"),...)
trace2 = List(...,REPORT("CALL_HOME"),...,REPORT("REBOOT"),...)
</pre></p><p><br></p><p>The formula will evaluate to True on the first, but to False on the second.
This is on contrast to the formula:</p><p><br></p><p><pre>
eventually(REPORT("REBOOT")) implies eventually(REPORT("CALL_HOME"))
</pre></p><p><br></p><p>which will evaluate to True on both traces.</p><p><br></p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>the formula that must be True if <i>this</i> evaluates to True.</p></dd><dt>returns</dt><dd class="cmt"><p>the <i>causes</i>-formula.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a>
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a>
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a>
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="tracecontract.Formulas.Formula#except" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="except(block:Formulas.this.Block):Formulas.this.Formula"></a>
      <a id="except(Block):Formula"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">except</span><span class="params">(<span name="block">block: <a href="Formulas.html#Block=PartialFunction[Event,Formulas.this.Formula]" class="extmbr" name="tracecontract.Formulas.Block">Block</a></span>)</span><span class="result">: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Hierarchical composition of formulas.</p><div class="fullcomment"><div class="comment cmt"><p>Hierarchical composition of formulas.
The formula <i>f except b</i> has the following interpretation: <i>f</i> is
evaluated until it either evaluates to True or False, <b>or</b> until the
block <i>b</i> is defined for the incoming event, in which case evaluation continues
with <i>b(e)</i>. In this case <i>f</i> is just ignored (it is <u>not</u> evaluated as if it was the end of the trace).</p><p>Take for example the following formula:</p><p><br></p><p><pre>
never(REPORT("REBOOT")) except {case FAIL(_) => eventually("REBOOT")}
</pre></p><p><br></p><p>This formula states that there should be no reboot, unless a fail is observed, in
which case a reboot must thereafter eventually occur.</p><p><br></p><p>The operator can be used to model hierarchical state charts (as in: <i>statemachine except supertransitions</i>).</p><p><br></p></div><dl class="paramcmts block"><dt class="param">block</dt><dd class="cmt"><p>the transition block that will release the formula (<i>this</i>) from having to be satisfied.</p></dd><dt>returns</dt><dd class="cmt"><p>the <i>except</i>-formula.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="tracecontract.Formulas.Formula#implies" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="implies(that:Formulas.this.Formula):Formulas.this.Formula"></a>
      <a id="implies(Formula):Formula"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">implies</span><span class="params">(<span name="that">that: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>)</span><span class="result">: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Defines propositional logical implication.</p><div class="fullcomment"><div class="comment cmt"><p>Defines propositional logical implication.
If <i>this</i> eventually evaluates to True, then <i>that</i> must eventually evaluate to True.
If <i>this</i> eventually evaluates to False, the implication also evaluates to True.
Note that <i>this</i> may not evaluate to True immediately (as in classical
propositional logic) but may take several steps to do so. However, <i>that</i> is monitored <b>right away</b>. That
is, we do not wait until <i>this</i> evaluates to either False or True.
Take for example the following formula:</p><p><br></p><p><pre>
eventually(REPORT("REBOOT")) implies eventually(REPORT("CALL_HOME"))
</pre></p><p><br></p><p>This formula states that (from <i>&quot;now on&quot;</i>) if there is eventually
a report of a reboot, then there should also eventually in the trace, either before
or after the report on the reboot, be a report on call to home. This formula
will return true on both of the following traces:</p><p><br></p><p><pre>
trace1 = List(...,REPORT("REBOOT"),...,REPORT("CALL_HOME"),...)
trace2 = List(...,REPORT("CALL_HOME"),...,REPORT("REBOOT"),...)
</pre></p><p><br></p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>the formula that must be True if <i>this</i> evaluates to True.</p></dd><dt>returns</dt><dd class="cmt"><p>the formula representing the implication.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a>
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="tracecontract.Formulas.Formula#onfail" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onfail(code:=&gt;Unit):Formulas.this.Formula"></a>
      <a id="onfail(⇒Unit):Formula"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onfail</span><span class="params">(<span name="code">code: ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="result">: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Attaches to a liveness formula a block of code to be executed in case the formula fails to be satisfied before the end of the trace.</p><div class="fullcomment"><div class="comment cmt"><p>Attaches to a liveness formula a block of code to be executed in case the formula fails to be satisfied before the end of the trace.
A formula of the form <i>f onfail {code}</i> will evaluate as <i>f</i> until the end of the trace. In case it at that point
evaluates to false as a liveness violation (a missing event), the code block <i>code</i> is executed.
The following example illustrates how <i>onfail</i> is used to print the name of a command that does not succeed:</p><p><br></p><p><pre>
class Requirement extends Monitor[Event] {
  require {
    case COMMAND(x) =>
      hot {
        case SUCCESS(`x`) => ok
      } onfail {
        println("command " + x + " did not succeed")
      }
  }
}
</pre></p><p><br></p></div><dl class="paramcmts block"><dt class="param">code</dt><dd class="cmt"><p>the code to be executed in case of a liveness violation.</p></dd><dt>returns</dt><dd class="cmt"><p>the original formula. That is, the <i>onfail</i> method returns the original formula, but has as side effect to
record the code block.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></dd></dl></div>
    </li><li name="tracecontract.Formulas.Formula#onfail" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onfail(text:String):Formulas.this.Formula"></a>
      <a id="onfail(String):Formula"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onfail</span><span class="params">(<span name="text">text: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Attaches to a liveness formula a string to be printed in case the formula fails to be satisfied before the end of the trace.</p><div class="fullcomment"><div class="comment cmt"><p>Attaches to a liveness formula a string to be printed in case the formula fails to be satisfied before the end of the trace.
A formula of the form <i>f onfail text</i> will evaluate as <i>f</i> until the end of the trace. In case it at that point
evaluates to false as a liveness violation (a missing event), the string <i>text</i> is printed on standard out
in addition to the default error message. This can be used to print additional information about data objects.
The following example illustrates how <i>onfail</i> is used to print the name of a command that does not succeed:</p><p><br></p><p><pre>
class Requirement extends Monitor[Event] {
  require {
    case COMMAND(x) =>
      hot {
        case SUCCESS(`x`) => ok
      } onfail ("command " + x + " did not succeed")
  }
}
</pre></p><p><br></p></div><dl class="paramcmts block"><dt class="param">text</dt><dd class="cmt"><p>the string to be printed in case of a liveness violation.</p></dd><dt>returns</dt><dd class="cmt"><p>the original formula. That is, the <i>onfail</i> method returns the original formula, but has as side effect to
record the text message.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></dd></dl></div>
    </li><li name="tracecontract.Formulas.Formula#or" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="or(that:Formulas.this.Formula):Formulas.this.Formula"></a>
      <a id="or(Formula):Formula"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">or</span><span class="params">(<span name="that">that: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>)</span><span class="result">: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Logical <i>or</i> (disjunction) of two formulas.</p><div class="fullcomment"><div class="comment cmt"><p>Logical <i>or</i> (disjunction) of two formulas.
The formula evaluates to True if and only if one of the two
formulas evaluate to True.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>the right hand argument of the disjunction.</p></dd><dt>returns</dt><dd class="cmt"><p>the <i>or</i>-formula.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
      <a id="synchronized[T0](⇒T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="tracecontract.Formulas.Formula#then" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="then(that:Formulas.this.Formula):Formulas.this.Formula"></a>
      <a id="then(Formula):Formula"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">then</span><span class="params">(<span name="that">that: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>)</span><span class="result">: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sequential composition of formulas.</p><div class="fullcomment"><div class="comment cmt"><p>Sequential composition of formulas.
The formula <i>f<sub>1</sub> then f<sub>2</sub></i> has the following interpretation:
<i>f<sub>1</sub></i> is first evaluated. If it evaluates to False, the whole formula evaluates to False.
If it evaluates to True, evaluation continues with <i>f<sub>2</sub></i>.
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>the formula that is evaluated after <i>this</i>.</p></dd><dt>returns</dt><dd class="cmt"><p>the <i>then</i>-formula.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></dd></dl></div>
    </li><li name="tracecontract.Formulas.Formula#unless" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="unless(that:Formulas.this.Formula):Formulas.this.Formula"></a>
      <a id="unless(Formula):Formula"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">unless</span><span class="params">(<span name="that">that: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>)</span><span class="result">: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Defines the LTL weak until operator, here called unless.</p><div class="fullcomment"><div class="comment cmt"><p>Defines the LTL weak until operator, here called unless.
The property <i>f<sub>1</sub> unless f<sub>2</sub></i> states that <i>f<sub>1</sub></i> must be True in every step
until <i>f<sub>2</sub></i> becomes True or till the end of the trace if <i>f<sub>2</sub></i> never becomes True.
The following equality holds:</p><p><br></p><p><pre>
f1 unless f2 == (f1 until f2) or always(f1)
</pre></p><p><br></p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>the formula that may eventually become True, thereby permitting <i>this</i> to no longer be True.</p></dd><dt>returns</dt><dd class="cmt"><p>the <i>unless</i>-formula.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></dd></dl></div>
    </li><li name="tracecontract.Formulas.Formula#until" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="until(that:Formulas.this.Formula):Formulas.this.Formula"></a>
      <a id="until(Formula):Formula"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">until</span><span class="params">(<span name="that">that: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>)</span><span class="result">: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Defines the LTL until operator.</p><div class="fullcomment"><div class="comment cmt"><p>Defines the LTL until operator.
The property <i>f<sub>1</sub> until f<sub>2</sub></i> states that eventually <i>f<sub>2</sub></i> must become True, and until
then <i>f<sub>1</sub></i> must be True in every step (including now, but excluding the point where <i>f<sub>2</sub></i> becomes True).
</p></div><dl class="paramcmts block"><dt class="param">that</dt><dd class="cmt"><p>the formula that must eventually become True, thereby permitting <i>this</i> to no longer be True.</p></dd><dt>returns</dt><dd class="cmt"><p>the <i>until</i>-formula.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></dd></dl></div>
    </li><li name="tracecontract.Formulas.Formula#upto" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="upto(block:Formulas.this.Block):Formulas.this.Formula"></a>
      <a id="upto(Block):Formula"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">upto</span><span class="params">(<span name="block">block: <a href="Formulas.html#Block=PartialFunction[Event,Formulas.this.Formula]" class="extmbr" name="tracecontract.Formulas.Block">Block</a></span>)</span><span class="result">: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Formula bounded by a block of transitions.</p><div class="fullcomment"><div class="comment cmt"><p>Formula bounded by a block of transitions.
The formula <i>f upto b</i> has the following interpretation: <i>f</i> is
evaluated until it either evaluates to True or False, <b>or</b> until an
event <i>e</i> occurs for which <i>b.isDefinedAt(e)</i> is true.
The latter is not required to happen, but in case it does, what remains of the
formula <i>f</i> is evaluated as if it was the end of the trace, and any missing
events will be reported. If no errors occur due to this check, the formula continues as <i>b(e)</i>.</p><p>Take for example the following formula:</p><p><br></p><p><pre>
(never(FAIL("DRIVE")) and eventually(SUCCESS("DRIVE"))) upto {
  case COMMAND(x) => eventually(SUCCESS(x))
}
</pre></p><p><br></p><p>This formula states that there should be no <i>FAIL(&quot;DRIVE&quot;)</i> and eventually a <i>SUCCESS(&quot;DRIVE&quot;)</i>,
up and until a <i>COMMAND</i> of any kind is observed, if any, in which case a success of that
command should eventually be observed. Consider the following traces:</p><p><br></p><p><pre>
trace1 = List(REPORT("SOFARSOGOOD"),SUCCESS("DRIVE"),COMMAND("PICTURE"),SUCCESS("PICTURE"))
trace2 = List(REPORT("SOFARSOGOOD"),COMMAND("PICTURE"),SUCCESS("PICTURE"))
</pre></p><p><br></p><p>The first trace satisfies the property whereas the second does not.</p><p><br></p></div><dl class="paramcmts block"><dt class="param">block</dt><dd class="cmt"><p>the transitions that can terminate the monitoring of <i>this</i> formula.</p></dd><dt>returns</dt><dd class="cmt"><p>the <i>upto</i>-formula.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></dd></dl></div>
    </li><li name="tracecontract.Formulas.Formula#uptoEvent" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="uptoEvent(endEvent:Event):Formulas.this.Formula"></a>
      <a id="uptoEvent(Event):Formula"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">uptoEvent</span><span class="params">(<span name="endEvent">endEvent: <span class="extype" name="tracecontract.Formulas.Event">Event</span></span>)</span><span class="result">: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Formula bounded by an event.</p><div class="fullcomment"><div class="comment cmt"><p>Formula bounded by an event.
The formula <i>f uptoEvent e</i> has the following interpretation: <i>f</i> is
evaluated until it either evaluates to True or False, <b>or</b> until the
the event <i>e</i> occurs, whichever occurs first. In the latter case, what remains
of the formula <i>f</i> is evaluated as if it was the end of the trace, and any missing events will
be reported.</p><p>Take for example the following formula:</p><p><br></p><p><pre>
(never(FAIL("DRIVE")) and eventually(SUCCESS("DRIVE"))) uptoEvent COMMAND("REBOOT")
</pre></p><p><br></p><p>This formula states that there should be no <i>FAIL(&quot;DRIVE&quot;)</i> and eventually a <i>SUCCESS(&quot;DRIVE&quot;)</i>,
up and until a <i>COMMAND(&quot;REBOOT&quot;)</i> is observed, if any. Consider the following traces:</p><p><br></p><p><pre>
trace1 = List(REPORT("SOFARSOGOOD"),SUCCESS("DRIVE),COMMAND("REBOOT"),FAIL("DRIVE"))
trace1 = List(REPORT("SOFARSOGOOD"),COMMAND("REBOOT"),SUCCESS("DRIVE))
</pre></p><p><br></p><p>The first trace satisfies the property whereas the second does not.</p><p><br></p></div><dl class="paramcmts block"><dt class="param">endEvent</dt><dd class="cmt"><p>the event that will terminate evaluation of the formula (<i>this</i>).</p></dd><dt>returns</dt><dd class="cmt"><p>the <i>uptoEvent</i>-formula.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></dd></dl></div>
    </li><li name="tracecontract.Formulas.Formula#uptoMatch" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="uptoMatch(endPredicate:Event=&gt;Boolean):Formulas.this.Formula"></a>
      <a id="uptoMatch((Event)⇒Boolean):Formula"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">uptoMatch</span><span class="params">(<span name="endPredicate">endPredicate: (<span class="extype" name="tracecontract.Formulas.Event">Event</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Formula bounded by an event predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Formula bounded by an event predicate.
The formula <i>f uptoMatch p</i> has the following interpretation: <i>f</i> is
evaluated until it either evaluates to True or False, <b>or</b> until an
event <i>e</i> occurs for which <i>p(e)</i> is defined and yields true.
In the latter case, what remains of the formula <i>f</i> is evaluated as if it was the
end of the trace, and any missing events will be reported.</p><p>Take for example the following formula:</p><p><br></p><p><pre>
(never(FAIL("DRIVE")) and eventually(SUCCESS("DRIVE"))) uptoMatch {case COMMAND(_) => true}
</pre></p><p><br></p><p>This formula states that there should be no <i>FAIL(&quot;DRIVE&quot;)</i> and eventually a <i>SUCCESS(&quot;DRIVE&quot;)</i>,
up and until a <i>COMMAND</i> of any kind is observed, if any. Consider the following traces:</p><p><br></p><p><pre>
trace1 = List(REPORT("SOFARSOGOOD"),SUCCESS("DRIVE),COMMAND("PICTURE"),FAIL("DRIVE"))
trace2 = List(REPORT("SOFARSOGOOD"),COMMAND("PICTURE"),SUCCESS("DRIVE))
</pre></p><p><br></p><p>The first trace satisfies the property whereas the second does not.</p><p><br></p></div><dl class="paramcmts block"><dt class="param">endPredicate</dt><dd class="cmt"><p>the event predicate that is applied to event to determine when to stop monitor <i>this</i>.</p></dd><dt>returns</dt><dd class="cmt"><p>the <i>uptoMatch</i>-formula.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></dd></dl></div>
    </li><li name="tracecontract.Formulas.Formula#uptoRequired" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="uptoRequired(block:Formulas.this.Block):Formulas.this.Formula"></a>
      <a id="uptoRequired(Block):Formula"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">uptoRequired</span><span class="params">(<span name="block">block: <a href="Formulas.html#Block=PartialFunction[Event,Formulas.this.Formula]" class="extmbr" name="tracecontract.Formulas.Block">Block</a></span>)</span><span class="result">: <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Formula bounded by a block of transitions, one of which has to trigger eventually.</p><div class="fullcomment"><div class="comment cmt"><p>Formula bounded by a block of transitions, one of which has to trigger eventually.
The formula <i>f uptoRequired b</i> has the following interpretation: <i>f</i> is
evaluated until it either evaluates to True or False, <b>or</b> until an
event <i>e</i> occurs for which <i>b.isDefinedAt(e)</i> is true.
The latter is required to happen, and when it does, what remains of the
formula <i>f</i> is evaluated as if it was the end of the trace, and any missing
events will be reported. If no errors occur due to this check, the formula continues as <i>b(e)</i>.</p><p>Take for example the following formula:</p><p><br></p><p><pre>
(never(FAIL("DRIVE")) and eventually(SUCCESS("DRIVE"))) uptoRequired {
  case COMMAND(x) => eventually(SUCCESS(x))
}
</pre></p><p><br></p><p>This formula states that there should be no <i>FAIL(&quot;DRIVE&quot;)</i> and eventually a <i>SUCCESS(&quot;DRIVE&quot;)</i>,
up and until a <i>COMMAND</i> of any kind is observed, required, in which case a success of that
command should eventually be observed. Consider the following traces:</p><p><br></p><p><pre>
trace1 = List(REPORT("SOFARSOGOOD"),SUCCESS("DRIVE"),COMMAND("PICTURE"),SUCCESS("PICTURE"))
trace2 = List(REPORT("SOFARSOGOOD"),COMMAND("PICTURE"),SUCCESS("PICTURE"))
trace3 = List(REPORT("SOFARSOGOOD"),SUCCESS("DRIVE"))
</pre></p><p><br></p><p>The first trace satisfies the property whereas the second an third do not.</p><p><br></p></div><dl class="paramcmts block"><dt class="param">block</dt><dd class="cmt"><p>the transitions that will terminate the monitoring of <i>this</i> formula.</p></dd><dt>returns</dt><dd class="cmt"><p>the <i>uptoRequired</i>-formula.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a>
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a>
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scala.Serializable">
              <h3>Inherited from <span class="extype" name="scala.Serializable">Serializable</span></h3>
            </div><div class="parent" name="java.io.Serializable">
              <h3>Inherited from <span class="extype" name="java.io.Serializable">Serializable</span></h3>
            </div><div class="parent" name="scala.Product">
              <h3>Inherited from <span class="extype" name="scala.Product">Product</span></h3>
            </div><div class="parent" name="scala.Equals">
              <h3>Inherited from <span class="extype" name="scala.Equals">Equals</span></h3>
            </div><div class="parent" name="tracecontract.Formulas.Formula">
              <h3>Inherited from <a href="Formulas$Formula.html" class="extype" name="tracecontract.Formulas.Formula">Formula</a></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
      <script defer="defer" type="text/javascript" id="jquery-js" src="../lib/jquery.js"></script><script defer="defer" type="text/javascript" id="jquery-ui-js" src="../lib/jquery-ui.js"></script><script defer="defer" type="text/javascript" id="tools-tooltip-js" src="../lib/tools.tooltip.js"></script><script defer="defer" type="text/javascript" id="template-js" src="../lib/template.js"></script>
    </body>
      </html>